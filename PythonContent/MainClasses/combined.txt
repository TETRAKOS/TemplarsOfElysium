==== Entities.py ====


import pygame
import Items
import UIElements
import Utils
import json
#from Overworld_game import Grid


def get_distance_from_actors(actor1,actor2):
    distance_x = abs(actor1.pos[0] - actor2.pos[0])
    distance_y = abs(actor1.pos[1] - actor2.pos[1])
    actor_distance = max(distance_x, distance_y)
    return actor_distance
class Actor:
    def __init__(self, pos, icon):
        self.pos = pos

        self.icon = pygame.image.load(icon)
        self.rect = pygame.Rect(pos, self.icon.get_size())
        self.name = "Unknown"
        self.event = "use"
        self.collision = True
    def onhover(self,event_pos):
        return self.rect.collidepoint(event_pos)
    def getinfo(self):
        return self.name
    def is_clicked(self, mouse_pos):
        return self.event
    def event_use(self, actor):
        print(f"used by{actor}")
        pass
class Block(Actor):
    def __init__(self, pos, sprite_path):
        super().__init__(pos, sprite_path)
        self.collision = True
class Wall(Actor):
    def __init__(self, pos, sprite_path):
        super().__init__(pos, sprite_path)
        self.name = "Concrete wall"
class Door(Actor):
    def __init__(self, pos, icon):
        super().__init__(pos, icon)
        self.name = "Door"
        self.icon = pygame.image.load("Assets/Sprites/Entities/MapAssets/Door/Door_closed.png")
        self.event = "use"
        self.collision = True


    def event_use(self,actor):
        if self.collision:
            self.collision = False
            self.icon = pygame.image.load("Assets/Sprites/Entities/MapAssets/Door/Door_opened.png")
        else:
            self.collision = True
            self.icon = pygame.image.load("Assets/Sprites/Entities/MapAssets/Door/Door_closed.png")

    #def __str__(self):
     #   print("Wall")
class Health_component:
    def __init__(self, actor_ref):
        self.actor_ref = actor_ref
        self.health = 100
        self.max_health = 100
    def take_damage(self, damage):
        self.health -= damage
        self.actor_ref.game.check_health()
    def heal(self,intake):
        self.health += intake
        if self.health > self.max_health:
            self.health = self.max_health
class Inventory_component:
    def __init__(self, actor_ref):
        self.actor_ref = actor_ref
        self.items = []

    def add_item(self, item):
        self.items.append(item)
        print(f"Added {item.name} to inventory")

    def remove_item(self, item):
        if item in self.items:
            self.items.remove(item)

    def equip_weapon(self, weapon):
        if isinstance(weapon, Items.Weapon):
            if isinstance(self.actor_ref, Player):
                self.actor_ref.equip_weapon(weapon)

    def use_item(self, item):
        if isinstance(item, Items.Item):
            item.use(self)

    def open_items_table(self):
        with open('Assets/dicts/item_table.js', 'r') as file:
            item_table = json.load(file)
            return item_table

    def deserialize(self, items_dump):
        item_table = self.open_items_table()
        items = []
        for item_id in items_dump:
            class_name = item_table.get(item_id)
            if class_name:
                item_class = getattr(Items, class_name, None)
                if item_class:
                    item_instance = item_class(player_ref=self.actor_ref)
                    items.append(item_instance)
                elif isinstance(class_name, Items.Weapon):
                     item_instance = item_class(player_ref=self.actor_ref)
                     items.append(item_instance)
                     print("weapon added")
        return items

    def serialize(self):
        item_table = self.open_items_table()
        items_dump = []
        for item in self.items:
            for key, value in item_table.items():
                if value == item.__class__.__name__:
                    items_dump.append(key)
                    break
        return items_dump

    def clean_inventory_data(self, items):
        cleaned_items = []
        for item in items:
            item = item.strip()  # Remove any leading/trailing whitespace
            if item.startswith('[') and item.endswith(']'):
                item = item[1:-1]  # Remove brackets
            cleaned_items.append(item)
        return cleaned_items


class Player(Actor):
    def __init__(self, game, pos, icon):
        super().__init__(pos, icon)
        self.game = game
        self.inventory = Inventory_component(self)
        self.health = Health_component(self)
        self.icon = pygame.image.load("Assets/Sprites/Entities/Creatures/Player/fig_east.png")
        self.rect = pygame.Rect(pos, self.icon.get_size())
        self.resource = 0
        self.name = "You"
        self.weapon = None
        self.event = "search"

    def handle_input(self, event):
        move = (0, 0)
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_w:
                move = (0, -1)
            elif event.key == pygame.K_s:
                move = (0, 1)
            elif event.key == pygame.K_a:
                self.icon = pygame.image.load("Assets/Sprites/Entities/Creatures/Player/fig_west.png")
                move = (-1, 0)
            elif event.key == pygame.K_d:
                self.icon = pygame.image.load("Assets/Sprites/Entities/Creatures/Player/fig_east.png")
                move = (1, 0)
        return move

    def pass_turn(self):
        self.game.pass_turn()

    def equip_weapon(self, weapon):
        self.weapon = weapon
        print(f"Equipped {weapon.name}")

    def attack(self, actor):
        if isinstance(self.weapon, Items.Weapon):
            if self.weapon.range >= get_distance_from_actors(self, actor):
                self.weapon.attack(actor)
                print(f"You attack {actor.name}")

    def search(self):
        print("You search around")

    def use(self, actor):
        if isinstance(actor, Actor) and not isinstance(actor, Hostile):
            a_distance = get_distance_from_actors(self, actor)
            if a_distance > 1:
                self.observe(actor)
            else:
                self.interact(actor)

    def observe(self, actor):
        if isinstance(actor, Actor):
            print(f"you looked at {actor.name}, it's too far to reach")
        else:
            print("incorrect Actor Type")

    def interact(self, actor):
        if isinstance(actor, Actor):
            print(f"You using {actor.name}")
            actor.event_use(self)
        else:
            print("incorrect Actor Type")

    def render_inventory(self, game_surface):
        inv_backdrop = UIElements.Rectangle(((game_surface.get_width() - 200), 0), (200, game_surface.get_height()), (70, 70, 70))
        inv_backdrop.draw(game_surface)
        y_offset = 50
        for item in self.inventory.items:
            item_name = item.name
            item_text = UIElements.TextRenderer(self.game.font_small, (255, 255, 255))
            item_text.draw_text(game_surface, item_name, (game_surface.get_width() - 190, y_offset), 190)
            if isinstance(item, Items.Weapon) and item == self.weapon:
                item_text.draw_text(game_surface, "(Equipped)", (game_surface.get_width() - 100, y_offset), 190)
            if not isinstance(item, Items.Weapon) and item.icon:
                rescaled_icon = pygame.transform.scale(item.icon, (32, 32))
                game_surface.blit(rescaled_icon, (game_surface.get_width() - 220, y_offset))
            y_offset += 30

    def handle_inventory_click(self, mouse_pos):
        y_offset = 50
        for item in self.inventory.items:
            item_rect = pygame.Rect((self.game.surface.get_width() - 190, y_offset), (190, 30))
            if item_rect.collidepoint(mouse_pos):
                self.game.popup = InventoryPopup(item, (mouse_pos[0], mouse_pos[1]), self.game.surface)
                return
            y_offset += 30

    def calculate_hit_chance(self, target):
        if not isinstance(self.weapon, Items.RangedWeapon):
            return 0
        distance = max(abs(self.pos[0] - target.pos[0]), abs(self.pos[1] - target.pos[1]))
        base_chance = 100 - (distance * 5)
        return max(min(base_chance, 95), 5)

    def death(self):
        print(f"{self.name} died")
        pass

class InventoryPopup:
    def __init__(self, item, pos, surface):
        self.item = item
        self.pos = pos
        self.surface = surface
        self.font = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 16)
        self.use_button = UIElements.Button("Use", (pos[0], pos[1]), (50, 50), self.font)
        self.discard_button = UIElements.Button("Discard", (pos[0] - 60, pos[1]), (75, 50), self.font)

    def draw(self):
        self.use_button.draw(self.surface)
        self.discard_button.draw(self.surface)

    def handle_click(self, mouse_pos):
        if self.use_button.is_clicked(mouse_pos):
            return "use"
        elif self.discard_button.is_clicked(mouse_pos):
            return "discard"
        return None


class Hostile(Actor):
    def __init__(self, game, pos, icon):
        super().__init__(pos, icon)
        self.game = game
        self.icon = pygame.image.load("Assets/Sprites/Entities/Creatures/Walker/walker.png")
        self.rect = pygame.Rect(pos, self.icon.get_size())
        self.name = "hostile"
        self.event = "attack"
        self.health = 5
        self.alive = True
        self.damage = 12

    def is_spotted(self):
        return self.game.visibility_grid[self.pos[1]][self.pos[0]]

    def take_damage(self, damage):
        self.health -= damage
        if self.health <= 0:
            print(f"{self.name} is dead")
            self.death()

    def death(self):
        self.icon = pygame.image.load("Assets/Sprites/Entities/Creatures/Dead/dead.png")
        self.alive = False
        self.collision = False

    def take_turn(self, player_pos):
      #  print("Take turn")
        if self.alive and self.is_spotted():
            distance = max(abs(self.pos[0] - player_pos[0]), abs(self.pos[1] - player_pos[1]))
            if distance <= 1:
                self.attack(player_pos)

            else:
                path = self.find_path(player_pos)
                print("find_path")
                if path:
                    self.move_towards(path)
                    print("moving")
    def attack(self, player_pos):
        print(f"{self.name} attacks the player at {player_pos}")
        self.game.player.health.take_damage(self.damage)
    def find_path(self, target_pos):
        return Utils.a_star_search(self.game.grid, tuple(self.pos), tuple(target_pos), self.game)

    def move_towards(self, path):
        if path:
            next_pos = path[0]
            if not self.is_tile_occupied(next_pos):
                self.game.grid.remove_from_cell(self.pos[0], self.pos[1], self)
                self.pos = list(next_pos)
                self.game.grid.set_cell(self.pos[0], self.pos[1], self)
                self.rect.topleft = (self.pos[0] * self.game.grid.cell_size, self.pos[1] * self.game.grid.cell_size)
                self.game.update_hostile_positions()
                print(f"{self.name} moved to {self.pos}")

    def is_tile_occupied(self, pos):
        for hostile in self.game.enemies:
            if hostile != self and hostile.pos == list(pos):
                return True
        return False


class Walker(Hostile):
    def __init__(self, pos):
        super().__init__(pos, "Assets/Sprites/Entities/Creatures/Walker/walker.png")
        self.name = "Walker"
class Loot(Actor):
    def __init__(self, game, pos, icon):
        super().__init__(pos, icon)
        self.game = game
        self.items = []  #
        self.name = "Bag with goods"
        self.enabled = True

    def event_use(self,player):
        if self.enabled:
            for item in self.items:
                    self.game.player.inventory.add_item(item)
            self.enabled = False
            self.icon = pygame.image.load("Assets\Sprites\Entities\MapAssets\Loot\Bag\Bag_o.png")
            #self.items = []  # Clear the loot after picking up
        return "use"
class Elevator(Actor):
    def __init__(self, game, pos, icon):
        super().__init__(pos, icon)
        self.collision = False
        self.name = "Elevator"

==== Global.py ====

import json

import pygame
import sys
from PythonContent.MainClasses.UIElements import ImageButton
from UIElements import Button, TextRenderer
import sqlite3

class Technology:
    def __init__(self, name, dependencies=None, position=(50, 50)):
        self.name = name
        self.dependencies = dependencies if dependencies else []
        self.position = position
        self.researched = False
        self.tech_tree = None

    def set_tech_tree(self, tech_tree):
        self.tech_tree = tech_tree

    def can_research(self):
        return all(self.tech_tree[dep].researched for dep in self.dependencies)

tech_tree = {
    "Survival equipment": Technology("Survival equipment", None, position=(25, 250)),
    "Basic Firearms": Technology("Basic Firearms", dependencies=["Survival equipment"], position=(275, 250)),
    "Buckshot": Technology("Buckshot", dependencies=["Basic Firearms"], position=(425, 400)),
    "Automatics": Technology("Automatics", dependencies=["Basic Firearms"], position=(425, 100)),
    "Vitals stabilizers": Technology("Vitals stabilizers", None, position=(50, 450)),
    "Laser": Technology("Laser", dependencies=["Automatics", "Buckshot"], position=(625, 250)),
    "Advanced Medicine": Technology("Advanced Medicine", dependencies=["Vitals stabilizers", "Laser"], position=(800, 450)),
}

for tech in tech_tree.values():
    tech.set_tech_tree(tech_tree)

class TechTreeUI:
    def __init__(self, surface, font, tech_tree, db_connection, db_cursor):
        self.surface = surface
        self.font = font
        self.tech_tree = tech_tree
        self.buttons = {}
        self.db_connection = db_connection
        self.db_cursor = db_cursor
        self.create_buttons()
        self.load_researched_technologies()

    def load_researched_technologies(self):
        try:
            self.db_cursor.execute("SELECT tech FROM profile_data")
            result = self.db_cursor.fetchone()
            if result and result[0]:
                researched_techs = result[0].split(',')
                for tech_name in researched_techs:
                    if tech_name in self.tech_tree:
                        self.tech_tree[tech_name].researched = True
                self.update_buttons()
        except sqlite3.Error as e:
            print(f"Error loading researched technologies: {e}")

    def save_researched_technologies(self):
        researched_techs = ','.join([tech.name for tech in self.tech_tree.values() if tech.researched])
        try:
            self.db_cursor.execute("UPDATE profile_data SET tech = ?", (researched_techs,))
            self.db_connection.commit()
            print("Researched technologies saved successfully.")
        except sqlite3.Error as e:
            print(f"Error saving researched technologies: {e}")

    def create_buttons(self):
        button_width = 175
        button_height = 75
        for tech in self.tech_tree.values():
            button = Button(tech.name, tech.position, (button_width, button_height), self.font, enabled=tech.can_research(),
                            disabled_color=(55, 55, 55), selected_color=(0, 255, 0))
            self.buttons[tech.name] = button

    def draw(self):
        for button in self.buttons.values():
            button.draw(self.surface)
        self.draw_lines()

    def draw_lines(self):
        for tech_name, tech in self.tech_tree.items():
            for dep_name in tech.dependencies:
                dep = self.tech_tree[dep_name]
                start_pos = self.get_button_center(self.buttons[dep_name])
                end_pos = self.get_button_center(self.buttons[tech_name])
                pygame.draw.line(self.surface, (125, 175, 125), start_pos, end_pos, 2)

    def get_button_center(self, button):
        return (button.position[0] + button.size[0] // 2, button.position[1] + button.size[1] // 2)

    def handle_event(self, event):
        for tech_name, button in self.buttons.items():
            if button.is_clicked(event.pos):
                tech = self.tech_tree[tech_name]
                if tech.can_research() and not tech.researched:
                    tech.researched = True
                    self.update_buttons()
                    print(f"Researched {tech.name}")
                    self.save_researched_technologies()
                    self.add_to_storage(tech.name)

    def update_buttons(self):
        for tech_name, button in self.buttons.items():
            tech = self.tech_tree[tech_name]
            button.set_enabled(tech.can_research() and not tech.researched)
            if tech.researched:
                button.selected = True

    def add_to_storage(self, tech_name):
        with open('Assets/dicts/tech_tree.js', 'r') as file:
            tech_table = json.load(file)
        try:
            print(tech_name)
            item_id = tech_table.get(tech_name)
            print(item_id)
            print(f"Item ID for {tech_name}: {item_id}")
            if item_id:
                self.db_cursor.execute("SELECT storage FROM profile_data")
                storage_result = self.db_cursor.fetchone()
                storage_items = storage_result[0].split(',') if storage_result[0] else []
                storage_items.append(item_id)
                storage_str = ','.join(storage_items)
                self.db_cursor.execute("UPDATE profile_data SET storage = ?", (storage_str,))
                self.db_connection.commit()
                print(f"Added {tech_name} to storage.")
            else:
                print(f"Item ID for {tech_name} not found.")
        except sqlite3.Error as e:
            print(f"Error adding item to storage: {e}")
class Shell:
    def __init__(self, surface, font, font_small, gameIcon, screen, save):
        self.save_data = save[1]
        self.surface = surface
        self.font = font
        self.screen = screen
        self.font_small = font_small
        self.gameIcon = gameIcon
        self.bgc = (45, 48, 44)
        self.b_bgc = (35, 38, 34)
        self.selected_fcl = None
        pygame.display.set_icon(self.gameIcon)
        print(self.save_data)
        self.db_connection = None
        self.db_cursor = None
        self.profile_data = None
        self.initialize_database()
        self.tech_tree_ui = None

    def initialize_database(self):
        try:
            self.db_connection = sqlite3.connect(self.save_data)
            self.db_cursor = self.db_connection.cursor()
            self.fetch_profile_data()
        except sqlite3.Error as e:
            print(f"Database error: {e}")

    def fetch_profile_data(self):
        try:
            self.db_cursor.execute("SELECT * FROM profile_data")
            self.profile_data = self.db_cursor.fetchall()
            print("Profile data fetched successfully:", self.profile_data)

            # Check if the 'day' field is empty and update it if necessary
            if not self.profile_data:
                self.db_cursor.execute("INSERT INTO profile_data (day, tech, advances, storage, gear) VALUES (?, ?, ?, ?, ?)",
                                       (1, '', '', '', ''))
                self.db_connection.commit()
                print("Default data inserted successfully.")
            else:
                for row in self.profile_data:
                    if row[0] is None:  # Assuming 'day' is the first column
                        self.db_cursor.execute("UPDATE profile_data SET day = ? WHERE rowid = ?", (1, row[0]))
                        self.db_connection.commit()
                        print("Updated 'day' field to 1.")

        except sqlite3.Error as e:
            print(f"Error fetching profile data: {e}")

    def mission_screen(self):
        factory_d = pygame.image.load("Assets/Sprites/Entities/Buildings/Factory/Factory_default.png")
        factory_h = pygame.image.load("Assets/Sprites/Entities/Buildings/Factory/Factory_highlighted.png")
        factory_s = pygame.image.load("Assets/Sprites/Entities/Buildings/Factory/Factory_selected.png")
        admin_d = pygame.image.load("Assets/Sprites/Entities/Buildings/Administration/admin_default.png")
        admin_h = pygame.image.load("Assets/Sprites/Entities/Buildings/Administration/admin_highlight.png")
        admin_s = pygame.image.load("Assets/Sprites/Entities/Buildings/Administration/admin_selected.png")
        gardens_d = pygame.image.load("Assets/Sprites/Entities/Buildings/Gardens/Gardens_default.png")
        gardens_h = pygame.image.load("Assets/Sprites/Entities/Buildings/Gardens/Gardens_highlight.png")
        gardens_s = pygame.image.load("Assets/Sprites/Entities/Buildings/Gardens/Gardens_selected.png")
        tower_counter = pygame.image.load("Assets/Sprites/Backdrops/Circle.png")
        tower_cb = tower_counter.get_rect(center=(500, (self.surface.get_height() // 2)))
        command_image = pygame.image.load("Assets/Sprites/Entities/Buildings/Tower/Tower.png")
        command_pl = (526, 59)
        circle_map = pygame.image.load("Assets/Sprites/Backdrops/Circle.png")
        circle_image = circle_map.get_rect(center=(500, (self.surface.get_height() // 2)))
        raid_main = TextRenderer(self.font, color=(255, 255, 255))
        raid_description = TextRenderer(self.font_small, color=(255, 255, 255))
        prep_raid_btn = Button("Prepare for Intrusion", (50, 450), (300, 75), self.font, enabled=False)

        raid_btn, tech_btn, units_btn, info_btn = self.low_buttons_array("Mission")
       # save_btn, load_btn, options_btn, quit_btn = self.high_buttons_array()
        haz1_bld = ImageButton(factory_d, factory_h, factory_s, (500, 116), (122, 292))
        haz2_bld = ImageButton(admin_d, admin_h, admin_s, (412, 46), (170, 260))
        haz3_bld = ImageButton(gardens_d, gardens_h, gardens_s, (380, 200), (162, 259))
        raid_mt = "Select facility for intrusion"
        raid_subt = ("Different facilities store different"
                      " types of resources, choose as needed")
        menu_running = True
        while menu_running:
            mouse_pos = pygame.mouse.get_pos()
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    menu_running = False
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if raid_btn.is_clicked(event.pos):
                        pass
                    elif tech_btn.is_clicked(event.pos):
                        self.tech_menu()
                        menu_running = False
                    elif units_btn.is_clicked(event.pos):
                        self.inventory_screen()
                        menu_running = False
                        print("Units Button Clicked")
                    elif info_btn.is_clicked(event.pos):
                        pass
                        # menu_running = False
                    elif haz1_bld.is_clicked(event.pos):
                        haz1_bld.in_focus(True)
                        haz2_bld.in_focus(False)
                        haz3_bld.in_focus(False)
                        print("Factory Button Clicked")
                        raid_mt = "Factory"
                        raid_subt = ("Production part of the Tower, storing mechanical components and engineering "
                                      "blueprints, occupied by the Cult of the Hammer, high-tech aggressive combatants,"
                                      "high environment hazards, mechanical threats")
                        self.selected_fcl = "Factory"
                    elif haz2_bld.is_clicked(event.pos):
                        haz2_bld.in_focus(True)
                        haz3_bld.in_focus(False)
                        haz1_bld.in_focus(False)
                        print("Admin Button Clicked")
                        raid_mt = "Administration"
                        raid_subt = ("Control part of the Tower, managing the Tower's resources, stores a lot of "
                                     "important administrative data, signs of scavengers and mutants, automated defense systems,"
                                     "low-tech nature of office environment suggests low chance of environment hazards")
                        self.selected_fcl = "Administration"
                    elif haz3_bld.is_clicked(event.pos):
                        haz3_bld.in_focus(True)
                        haz2_bld.in_focus(False)
                        haz1_bld.in_focus(False)
                        print("Gardens Button Clicked")
                        raid_mt = "Gardens"
                        raid_subt = ("Gardens part of the Tower, stores food, water, and other necessary resources,"
                                     "biological hazard, occasional burst of mutated flora and fauna "
                                     "spreads all over different sections of tower, miriad of semi-sentient hostile "
                                     "entities, high-tech nature of the gardens and distorted nature suggests"
                                     " that this is a hazardous environment")
                        self.selected_fcl = "Gardens"
                    # elif save_btn.is_clicked(event.pos):
                    #     print("Save Button Clicked")
                    # elif load_btn.is_clicked(event.pos):
                    #     print("Load Button Clicked")
                    # elif prep_raid_btn.is_clicked(event.pos):
                        print("Preparation for Raid Button Clicked")
                        self.screen.search_new_state("game")
                        return
                    # elif options_btn.is_clicked(event.pos):
                    #     print("Options Button Clicked")
                    # elif quit_btn.is_clicked(event.pos):
                    #     menu_running = False

                haz1_bld.update(mouse_pos)
                haz2_bld.update(mouse_pos)
                haz3_bld.update(mouse_pos)
                self.surface.fill(self.bgc)
                prep_raid_btn.set_enabled(True if self.selected_fcl is not None else False)
                prep_raid_btn.update_text("Prepare for Intrusion" if self.selected_fcl is not None else "Select the facility")
                self.surface.blit(tower_counter, tower_cb)
                raid_btn.draw(self.surface)
                tech_btn.draw(self.surface)
                units_btn.draw(self.surface)
                info_btn.draw(self.surface)
                # save_btn.draw(self.surface)
                # load_btn.draw(self.surface)
                # options_btn.draw(self.surface)
                # quit_btn.draw(self.surface)
                haz1_bld.draw(self.surface)
                haz2_bld.draw(self.surface)
                haz3_bld.draw(self.surface)
                prep_raid_btn.draw(self.surface)

                self.surface.blit(command_image, command_pl)
                raid_main.draw_text(self.surface, raid_mt, (20, 15), 800)
                raid_description.draw_text(self.surface, raid_subt, (20, 60), 380)
                pygame.display.flip()

        return "shell"  # Return to the shell state if the loop exits

    def high_buttons_array(self):
        save_btn = Button("Save", (620, 0), (100, 25), self.font_small, self.b_bgc)
        load_btn = Button("Load", (720, 0), (100, 25), self.font_small, self.b_bgc)
        options_btn = Button("Options", (820, 0), (100, 25), self.font_small, self.b_bgc)
        quit_btn = Button("Quit", (920, 0), (100, 25), self.font_small, self.b_bgc)
        return save_btn, load_btn, options_btn, quit_btn

    def low_buttons_array(self, state):
        raid_btn = Button("Mission", (50, 550), (225, 50), self.font, self.b_bgc, enabled=True)
        if state == "Mission":
            raid_btn.set_enabled(False)
        tech_btn = Button("Tech", (275, 550), (225, 50), self.font, self.b_bgc, enabled=True)
        if state == "Tech":
            tech_btn.set_enabled(False)
        units_btn = Button("Gear", (500, 550), (225, 50), self.font, self.b_bgc, enabled=True)
        if state == "Gear":
            units_btn.set_enabled(False)
        info_btn = Button("Info", (725, 550), (225, 50), self.font, self.b_bgc, enabled=True)
        if state == "Info":
            info_btn.set_enabled(False)
        return raid_btn, tech_btn, units_btn, info_btn

    def tech_menu(self):
        tech_font = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 20)
        self.tech_tree_ui = TechTreeUI(self.surface, tech_font, tech_tree, self.db_connection, self.db_cursor)
        t_running = True
        raid_btn, tech_btn, gear_btn, misc_btn = self.low_buttons_array("Tech")
        while t_running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    t_running = False
                if event.type == pygame.MOUSEBUTTONDOWN:
                    self.tech_tree_ui.handle_event(event)
                    if event.button == 3:
                        self.mission_screen()
                        t_running = False
                    if raid_btn.is_clicked(event.pos):
                        self.mission_screen()
                        t_running = False
                    elif tech_btn.is_clicked(event.pos):
                        self.tech_menu()
                        t_running = False
                    elif gear_btn.is_clicked(event.pos):
                        self.inventory_screen()
                        t_running = False
                    elif misc_btn.is_clicked(event.pos):
                        print("Misc Button Clicked")

            self.surface.fill(self.bgc)
            self.tech_tree_ui.draw()
            raid_btn.draw(self.surface)
            tech_btn.draw(self.surface)
            gear_btn.draw(self.surface)
            misc_btn.draw(self.surface)
            pygame.display.flip()
    def inventory_screen(self):
        self.inventory_manager = InventoryManager(self.surface, self.font, self.db_connection, self.db_cursor)
        raid_btn, tech_btn, units_btn, info_btn = self.low_buttons_array("Gear")
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                self.inventory_manager.handle_event(event)
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if raid_btn.is_clicked(event.pos):
                        self.mission_screen()
                        running = False
                    elif tech_btn.is_clicked(event.pos):
                        self.tech_menu()
                        running = False
                    elif units_btn.is_clicked(event.pos):
                        self.inventory_screen()
                        pass
                    elif info_btn.is_clicked(event.pos):
                        pass
                        # menu_running = False

            self.surface.fill(self.bgc)
            self.inventory_manager.draw()
            raid_btn.draw(self.surface)
            tech_btn.draw(self.surface)
            units_btn.draw(self.surface)
            info_btn.draw(self.surface)
            pygame.display.flip()

        return "shell"


class InventoryManager:
    def __init__(self, surface, font, db_connection, db_cursor):
        self.surface = surface
        self.font = font
        self.db_connection = db_connection
        self.db_cursor = db_cursor
        self.gear_items = []
        self.storage_items = []
        self.load_inventory()
        self.create_buttons()

    def load_inventory(self):
        try:
            self.db_cursor.execute("SELECT gear, storage FROM profile_data")
            result = self.db_cursor.fetchone()
            if result:
                self.gear_items = self.clean_inventory_data(result[0].split(',')) if result[0] else []
                self.storage_items = self.clean_inventory_data(result[1].split(',')) if result[1] else []
        except sqlite3.Error as e:
            print(f"Error loading inventory: {e}")

    def clean_inventory_data(self, items):
        cleaned_items = []
        for item in items:
            item = item.strip()  # Remove any leading/trailing whitespace
            if item.startswith('[') and item.endswith(']'):
                item = item[1:-1]  # Remove brackets
            cleaned_items.append(item)
        return cleaned_items

    def save_inventory(self):
        gear_str = ','.join(self.gear_items)
        storage_str = ','.join(self.storage_items)
        try:
            self.db_cursor.execute("UPDATE profile_data SET gear = ?, storage = ?", (gear_str, storage_str))
            self.db_connection.commit()
            print("Inventory saved successfully.")
        except sqlite3.Error as e:
            print(f"Error saving inventory: {e}")

    def create_buttons(self):
        self.gear_buttons = []
        self.storage_buttons = []
        button_width = 150
        button_height = 50
        y_offset = 50

        for item in self.gear_items:
            button = Button(item, (50, y_offset), (button_width, button_height), self.font)
            self.gear_buttons.append(button)
            y_offset += 60

        y_offset = 50
        for item in self.storage_items:
            button = Button(item, (300, y_offset), (button_width, button_height), self.font)
            self.storage_buttons.append(button)
            y_offset += 60

    def draw(self):
        for button in self.gear_buttons:
            button.draw(self.surface)
        for button in self.storage_buttons:
            button.draw(self.surface)

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            for button in self.gear_buttons:
                if button.is_clicked(event.pos):
                    item = button.text
                    self.gear_items.remove(item)
                    self.storage_items.append(item)
                    self.create_buttons()
                    self.save_inventory()
                    print(f"Moved {item} from gear to storage")

            for button in self.storage_buttons:
                if button.is_clicked(event.pos):
                    item = button.text
                    self.storage_items.remove(item)
                    self.gear_items.append(item)
                    self.create_buttons()
                    self.save_inventory()
                    print(f"Moved {item} from storage to gear")


==== Items.py ====

import pygame
import Entities
import time
import Utils
import random

class Item:
    def __init__(self, player_ref=None):
        self.name = "Unknown"
        self.description = "No description provided."
        self.icon = None
        self.player_ref = player_ref

    def call_menu(self, inventory_ref):
        pass

    def use(self, inventory_ref):
        print(f"Can't use {self.name}!")
        return False

class Material(Item):
    def __init__(self, player_ref=None):
        super().__init__(player_ref)
        self.name = "Material"

class Weapon(Item):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.damage = 0
        self.range = 0

    def attack(self, actor):
        pass

class RangedWeapon(Weapon):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.range = 6
        self.damage = 2
        self.ammo = 2
        self.max_ammo = 2
        self.name = "ranged Weapon"
        self.icon = "Assets/Sprites/Items/Weapons/surv_gun.png"
        self.accuracy = 100
        self.sound = None
        pygame.mixer.init()

    def calculate_hit_chance(self, distance):
        return max(0, self.accuracy - (distance * 10))

    def attack(self, actor):
        self.fire_at(actor)
        self.player_ref.pass_turn()

    def fire_at(self, enemy):
        distance = Utils.get_distance_from_actors(self.player_ref, enemy)
        hit_chance = self.calculate_hit_chance(distance)
        if self.ammo > 0:
            self.ammo -= 1
            if random.randint(1, 100) <= hit_chance:
                enemy.take_damage(self.damage)
                print(f"Fired at {enemy.name} for {self.damage} damage!")
            else:
                if self.sound is not None:
                    pygame.mixer.music.load(self.sound)
                else:
                    pygame.mixer.music.load('Assets/Sound/sfx/smallarms_fire/sm1.wav')
                pygame.mixer.music.play()
                print("missed")
                if isinstance(self.player_ref, Entities.Player):
                    return None
            if self.sound is not None:
                pygame.mixer.music.load(self.sound)
            else:
                pygame.mixer.music.load('Assets/Sound/sfx/smallarms_fire/sm1.wav')
            pygame.mixer.music.play()
            if isinstance(self.player_ref, Entities.Player):
                return enemy.pos
        else:
            print("no ammo!")
            return None

    def reload(self):
        self.ammo = self.max_ammo
        print("Reloaded!")
        pygame.mixer.music.load("Assets/Sound/sfx/small_reload/smReload.wav")
        pygame.mixer.music.play()
        if isinstance(self.player_ref, Entities.Player):
            self.player_ref.pass_turn()

class Surv_pistol(RangedWeapon):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.damage = 1
        self.range = 6
        self.ammo = 2
        self.name = "Survival Pistol"
        self.icon = "Assets/Sprites/Items/Weapons/surv_gun.png"

class Shotgun(RangedWeapon):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.damage = 6
        self.range = 4
        self.ammo = 4
        self.max_ammo = 4
        self.name = "Shotgun"
        self.icon = "Assets/Sprites/Items/Weapons/shotgun.png"

class Pistol(RangedWeapon):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.damage = 2
        self.range = 8
        self.ammo = 10
        self.max_ammo = 10
        self.name = "Pistol"
        self.icon = "Assets/Sprites/Items/Weapons/pistol.png"

class Laser(RangedWeapon):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.damage = 4
        self.range = 10
        self.ammo = 32
        self.max_ammo = 32
        self.name = "Laser"
        self.icon = "Assets/Sprites/Items/Weapons/laser.png"
        self.sound = "Assets/Sound/sfx/laser/fire.wav"

    def attack(self, actor):
        for i in range(6):
            self.fire_at(actor)
            time.sleep(0.1)
        self.player_ref.pass_turn()

class Smg(RangedWeapon):
    def __init__(self, player_ref):
        super().__init__(player_ref)
        self.damage = 1
        self.range = 5
        self.ammo = 30
        self.max_ammo = 30
        self.name = "SMG"
        self.icon = "Assets/Sprites/Items/Weapons/smg.png"

    def attack(self, actor):
        for i in range(3):
            self.fire_at(actor)
            time.sleep(0.075)
        self.player_ref.pass_turn()

class Shard(Item):
    def __init__(self, player_ref=None):
        super().__init__(player_ref)
        self.name = "Metal shard"
        self.description = "A shard of unknown metal."
        self.icon = pygame.image.load("Assets/Sprites/Items/Materials/Shard/Shard.png")

class Cells(Item):
    def __init__(self, player_ref=None):
        super().__init__(player_ref)
        self.name = "Cells"
        self.description = "A collection of powercells."
        self.icon = pygame.image.load("Assets/Sprites/Items/Materials/Shard/cells.png")

class Box(Item):
    def __init__(self, player_ref=None):
        super().__init__(player_ref)
        self.name = "Polygel box"
        self.description = "A container with polygel."
        self.icon = pygame.image.load("Assets/Sprites/Items/Materials/Shard/box.png")

class MediPatch(Item):
    def __init__(self, player_ref=None):
        super().__init__(player_ref)
        self.name = "MediPatch"
        self.description = "A kit to restore small amount health."
        self.icon = pygame.image.load("Assets/Sprites/Items/Medical/mediPatch.png")

    def use(self, inventory_ref):
        inventory_ref.actor_ref.health.heal(25)
        inventory_ref.remove_item(self)
        inventory_ref.actor_ref.game.check_health()
        print(f"Healed with {self.name} by 25 HP!")
        return True

class MedInjector(Item):
    def __init__(self, player_ref=None):
        super().__init__(player_ref)
        self.name = "Medical Injector"
        self.description = "A syringe filled with life-saving chemicals"
        self.icon = pygame.image.load("Assets/Sprites/Items/Medical/Injector.png")

    def use(self, inventory_ref):
        inventory_ref.actor_ref.health.heal(50)
        inventory_ref.remove_item(self)
        inventory_ref.actor_ref.game.check_health()
        print(f"Healed with {self.name} by 50 HP!")
        return True


==== Main_menu.py ====

import pygame
from UIElements import TextRenderer, Button, InputBox
import os
import sqlite3

class Menu:
    def __init__(self, surface, screen):
        pygame.init()
        pygame.mixer.init()
        self.screen = screen
        self.surface = surface
        self.font_path = os.path.join("HomeVideo-Regular", "Assets/fonts/Game/HomeVideo-Regular.otf")
        self.font = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 48)
        self.button_font = TextRenderer(self.font, color=(255, 255, 255))
        self.music = pygame.mixer.Sound("Assets/Sound/Music/dreadful_horizon.wav")
        self.music.set_volume(0.4)
        self.music.play(-1)

        self.gameIcon = pygame.image.load("Assets/Sprites/icons/Icon33.png")
        pygame.display.set_caption("Raiders of Elysium")

        self.bgc = pygame.image.load("Assets/Sprites/Backdrops/NormalBackground.png")
        pygame.display.set_icon(self.gameIcon)

    def stop_music(self):
        self.music.stop()

    def run_menu(self):
        quit_button = Button("Quit", ((self.surface.get_width() - 220), 540), (200, 50), self.font, enabled=True)
        options_button = Button("Game Properties", ((self.surface.get_width() - 470), 480), (450, 50), self.font,
                                enabled=True)
        instant_action_button = Button("Instant Action", ((self.surface.get_width() - 420), 420), (400, 50),
                                       self.font, enabled=True)
        campaign_button = Button("Campaign", ((self.surface.get_width() - 260), 360), (240, 50), self.font,
                                 enabled=True)
        game_logo = self.gameIcon.get_rect(center=(120, (self.surface.get_height() // 2) - 150))
        game_logo_sized = pygame.transform.scale(self.gameIcon, (256, 256))
        running_menu = True
        while running_menu:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.stop_music()
                    self.screen.search_new_state("quit")
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if quit_button.is_clicked(event.pos):
                        self.stop_music()
                        self.screen.search_new_state("quit")
                    if instant_action_button.is_clicked(event.pos):
                        self.stop_music()
                        self.screen.search_new_state("game")
                    if campaign_button.is_clicked(event.pos):
                        return self.Run_CampaignMenu()

            self.surface.blit(self.bgc, (0,0))

            name_render = TextRenderer(self.font, color=(255, 255, 255))
            name_render.draw_text(self.surface, "RAIDERS OF ELYSIUM", (20, 20), 2000)

            # Draw the buttons
            self.surface.blit(game_logo_sized, game_logo)
            options_button.draw(self.surface)
            quit_button.draw(self.surface)
            instant_action_button.draw(self.surface)
            campaign_button.draw(self.surface)

            pygame.display.flip()

        return "menu"

    def new_game_menu(self):
        create_button = Button("confirm", ((self.surface.get_width() - 280), 480), (260, 50), self.font,
                               enabled=True)
        name_ib = InputBox(((self.surface.get_width() - 480), 480,), (200, 50), self.font)
        back_btn = Button("return", ((self.surface.get_width() - 220), 540), (200, 50), self.font, enabled=True)
        ng_run = True
        while ng_run:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.stop_music()
                    self.screen.search_new_state("quit")
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if create_button.is_clicked(event.pos):
                        self.new_gameSQL(name_ib.get_name())
                        self.stop_music()
                        self.screen.search_new_state("shell")
                    elif back_btn.is_clicked(event.pos):
                        return self.Run_CampaignMenu()
                name_ib.handle_event(event)
            self.surface.blit(self.bgc,(0,0))
            create_button.draw(self.surface)
            back_btn.draw(self.surface)
            name_ib.draw(self.surface)
            pygame.display.flip()

        return "menu"

    def new_gameSQL(self, profile_name=None):
        connection = sqlite3.connect("GameData/players.db")
        self.cursor = connection.cursor()
        if profile_name is not None:
            profile_dir = "GameData/Profiles/" + profile_name + ".db"
            self.cursor.execute('''CREATE TABLE IF NOT EXISTS player(
                        id INTEGER,
                        profile_dir TEXT NOT NULL,
                        profile_name TEXT NOT NULL)
                        ''')
            self.cursor.execute('SELECT COUNT(*) FROM player')
            counter = self.cursor.fetchone()[0]
            self.cursor.execute('''INSERT INTO player (id, profile_dir, profile_name)
                                           VALUES (?, ?, ?)''', (counter, profile_dir, profile_name))
            connection.commit()

            # Create a new profile database
            profile = sqlite3.connect("GameData/Profiles/" + profile_name + ".db")
            pcursor = profile.cursor()
            pcursor.execute('''CREATE TABLE IF NOT EXISTS profile_data(
                        day INTEGER,
                        tech TEXT NOT NULL,
                        advances TEXT NOT NULL,
                        storage TEXT NOT NULL,
                        gear TEXT NOT NULL
                        )''')

            profile.commit()
            pcursor.close()
            profile.close()

        self.cursor.close()
        connection.close()

    def Run_CampaignMenu(self):
        new_btn = Button("New Game", ((self.surface.get_width() - 280), 480), (260, 50), self.font, enabled=True)
        back_btn = Button("Back", ((self.surface.get_width() - 220), 540), (200, 50), self.font, enabled=True)
        loadgame_btn = Button("Load Game", ((self.surface.get_width() - 280), 420), (260, 50), self.font,
                              enabled=True)
        continue_btn = Button("Continue", ((self.surface.get_width() - 260), 360), (240, 50), self.font,
                              enabled=True)
        typer_render = TextRenderer(self.font, color=(255, 255, 255))
        land_image = pygame.image.load("Assets/Sprites/Screens/landing.png")
        game_logo = land_image.get_rect(center=(120, (self.surface.get_height() // 2) - 150))
        game_logo_sized = pygame.transform.scale(land_image, (256, 256))

        running_menu = True
        while running_menu:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.stop_music()
                    self.screen.search_new_state("quit")
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if back_btn.is_clicked(event.pos):
                        return self.run_menu()
                    if new_btn.is_clicked(event.pos):
                        return self.new_game_menu()
                    if loadgame_btn.is_clicked(event.pos):
                        print("Loading game...")
                        return self.load_game_menu()
                    if continue_btn.is_clicked(event.pos):
                        conn = sqlite3.connect("GameData/players.db")
                        cursor = conn.cursor()
                        cursor.execute("SELECT * FROM player ORDER BY id DESC LIMIT 1")
                        last_save = cursor.fetchone()
                        self.screen.save = last_save
                        print(last_save)
                        self.screen.search_new_state("shell")
                        return
            self.surface.blit(self.bgc,(0,0))  # Clear the surface for the campaign menu
            new_btn.draw(self.surface)
            back_btn.draw(self.surface)
            loadgame_btn.draw(self.surface)
            continue_btn.draw(self.surface)
            self.surface.blit(game_logo_sized, game_logo)
            typer_render.draw_text(self.surface, "Campaign Mode", (20, 20), 2000)
            pygame.display.flip()

        return "menu"

    def load_game_menu(self):
        back_btn = Button("Back", ((self.surface.get_width() - 220), 540), (200, 50), self.font, enabled=True)
        typer_render = TextRenderer(self.font, color=(255, 255, 255))

        # Connect to the database and retrieve the list of saved games
        conn = sqlite3.connect("GameData/players.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM player")
        saves = cursor.fetchall()
        conn.close()

        # Create buttons for each save
        load_buttons = []
        delete_buttons = []
        save_names = []
        y_offset = 100
        for save in saves:
            save_id, profile_dir, profile_name = save
            save_name = TextRenderer(self.font, color=(255, 255, 255), text=profile_name)
            load_btn = Button("Load", ((self.surface.get_width() - 400), y_offset), (180, 50), self.font, enabled=True)
            delete_btn = Button("Delete", ((self.surface.get_width() - 200), y_offset), (180, 50), self.font,
                                enabled=True)
            save_names.append(save_name)
            load_buttons.append((load_btn, save_id, profile_dir))  # Include save_id here
            delete_buttons.append((delete_btn, profile_dir))
            y_offset += 60

        running_menu = True
        while running_menu:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.stop_music()
                    self.screen.search_new_state("quit")
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if back_btn.is_clicked(event.pos):
                        return self.Run_CampaignMenu()
                    for load_btn, save_id, profile_dir in load_buttons:
                        if load_btn.is_clicked(event.pos):
                            self.load_game(save_id, profile_dir)
                            self.stop_music()
                            self.screen.search_new_state("shell")
                    for delete_btn, profile_dir in delete_buttons:
                        if delete_btn.is_clicked(event.pos):
                            self.delete_game(profile_dir)
                            return self.load_game_menu()

            self.surface.blit(self.bgc, (0, 0))
            typer_render.draw_text(self.surface, "Load Game", (20, 20), 2000)
            back_btn.draw(self.surface)
            y_offset = 100
            for save_name in save_names:
                save_name.draw_text(self.surface, None, ((self.surface.get_width() - 800), y_offset), 400)
                y_offset += 60
            for load_btn, _, _ in load_buttons:
                load_btn.draw(self.surface)
            for delete_btn, _ in delete_buttons:
                delete_btn.draw(self.surface)
            pygame.display.flip()

        return "menu"

    def load_game(self, save_id, profile_dir):
        print(f"Loading game with ID {save_id} from {profile_dir}")
        self.screen.save = (save_id, profile_dir)

    def delete_game(self, profile_dir):
        # Implement the logic to delete the game from the specified profile_dir
        print(f"Deleting game from {profile_dir}")
        conn = sqlite3.connect("GameData/players.db")
        cursor = conn.cursor()
        cursor.execute("DELETE FROM player WHERE profile_dir = ?", (profile_dir,))
        conn.commit()
        conn.close()
        os.remove(profile_dir)


==== MapGen.py ====

import pygame
import random
import Entities
import json
import os
from Mission_manager import Mission
import Items  # Ensure you import the Items module

def sorting_key(value):
    if isinstance(value, Entities.Player):
        return 0
    elif isinstance(value, Entities.Hostile):
        return 1
    elif isinstance(value, Entities.Actor):
        return 2
    elif isinstance(value, Entities.Wall):
        return 3
    elif isinstance(value, str):
        return 4
    else:
        return 5

class Grid:
    def __init__(self, width, height, cell_size, game):
        self.game = game
        self.width = width
        self.height = height
        self.cell_size = cell_size
        self.grid = [[[] for _ in range(width)] for _ in range(height)]
        self.rooms = []
        self.images = {}
        self.mission = Mission(self.game, self, "scout")
        self.asset_paths = self.load_asset_paths()
        self.load_images()
        self.item_table = self.load_item_table()
        self.extract_point = None

    def load_asset_paths(self):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        asset_path_file = os.path.join(script_dir, 'Assets', 'dicts', 'asset_paths.js')
        with open(asset_path_file, 'r') as f:
            return json.load(f)

    def load_room_layouts(self):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        asset_path_file = os.path.join(script_dir, 'Assets', 'dicts', 'rooms_layout.js')
        with open(asset_path_file, 'r') as f:
            return json.load(f)

    def load_room_content(self):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        asset_path_file = os.path.join(script_dir, 'Assets', 'dicts', 'rooms_content.js')
        with open(asset_path_file, 'r') as f:
            return json.load(f)

    def load_images(self):
        for key, path in self.asset_paths.items():
            self.images[key] = pygame.image.load(path)

    def load_item_table(self):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        item_table_file = os.path.join(script_dir, 'Assets', 'dicts', 'item_table.js')
        with open(item_table_file, 'r') as f:
            return json.load(f)

    def generate_dungeon(self):
        self.rooms = []
        room_layouts = self.load_room_layouts()
        room_content = self.load_room_content()
        name, basic, danger, loot, end = self.mission.generate_mission()
        layout_counts = {layout["layout"]: 0 for layout in room_layouts}
        attempts = 0
        max_attempts = (basic + danger + loot) * 3  # Limit attempts to avoid infinite loops

        # Find the elevator layout
        elevator_layout = next(layout for layout in room_layouts if layout["layout"] == "elevator")


        room_width = elevator_layout["x"]
        room_height = elevator_layout["y"]
        x = random.randint(1, self.width - room_width - 2)
        y = random.randint(1, self.height - room_height - 2)
        first_room = (x, y, room_width, room_height, elevator_layout["layout"], elevator_layout["loot_value"],
                      elevator_layout["danger"], elevator_layout["tile"])

        self.add_room(first_room)
        self.enrich_room(first_room, room_content)
        self.rooms.append(first_room)
        layout_counts[elevator_layout["layout"]] += 1

        # Generate middle rooms
        while len(self.rooms) < (basic + danger + loot - 1) and attempts < max_attempts:
            layout = random.choice([l for l in room_layouts if l["layout"] != "elevator"])
            if layout_counts[layout["layout"]] >= layout["max_count"]:
                attempts += 1
                continue

            room_width = layout["x"]
            room_height = layout["y"]
            x = random.randint(1, self.width - room_width - 2)
            y = random.randint(1, self.height - room_height - 2)
            new_room = (
                x, y, room_width, room_height, layout["layout"], layout["loot_value"], layout["danger"], layout["tile"])

            if not any(self.overlap(new_room, r) for r in self.rooms):
                self.add_room(new_room)
                self.enrich_room(new_room, room_content)
                self.rooms.append(new_room)
                layout_counts[layout["layout"]] += 1

            attempts += 1
        room_width = elevator_layout["x"]
        room_height = elevator_layout["y"]
        x = random.randint(1, self.width - room_width - 2)
        y = random.randint(1, self.height - room_height - 2)
        last_room = (x, y, room_width, room_height, elevator_layout["layout"], elevator_layout["loot_value"],
                     elevator_layout["danger"], elevator_layout["tile"])

        while self.overlap(last_room, self.rooms[-1]):
            x = random.randint(1, self.width - room_width - 2)
            y = random.randint(1, self.height - room_height - 2)
            last_room = (x, y, room_width, room_height, elevator_layout["layout"], elevator_layout["loot_value"],
                         elevator_layout["danger"], elevator_layout["tile"])

        self.add_room(last_room)
        self.set_cell(x,y,Entities.Elevator(self.game,(x,y),"Assets/Sprites/Entities/MapAssets/Technical/MissionManager/Elevator.png"))
        self.extract_point = [x,y]
        self.enrich_room(last_room, room_content)
        self.rooms.append(last_room)
        layout_counts[elevator_layout["layout"]] += 1

        for i in range(1, len(self.rooms)):
            self.connect_rooms(self.rooms[i - 1], self.rooms[i])

        self.encase_rooms()

        print(f"Generated {len(self.rooms)} rooms")
        for layout, count in layout_counts.items():
            print(f"{layout}: {count}")

        # Generate loot
        self.generate_loot()

    def generate_loot(self):
        for room in self.rooms:
            if room[5] > 0:  # Check if the room has a non-zero loot value
                x, y, _, _, _, loot_value, _, _ = room
                num_loots = random.randint(1, loot_value)  # Adjust the range as needed
                for _ in range(num_loots):
                    loot_pos_x = random.randint(x + 1, x + room[2] - 2)  # Avoid placing on walls
                    loot_pos_y = random.randint(y + 1, y + room[3] - 2)  # Avoid placing on walls
                    loot_box = Entities.Loot(self.game, [loot_pos_x, loot_pos_y],
                                             "Assets/Sprites/Entities/MapAssets/Loot/Bag/Bag.png")
                    self.set_cell(loot_pos_x, loot_pos_y, loot_box)

                    # Add items to the loot box
                    num_items = random.randint(1, 3)  # Adjust the range as needed
                    for _ in range(num_items):
                        item_id = random.choice(list(self.item_table.keys()))
                        item_class = getattr(Items, self.item_table[item_id])
                        if not issubclass(item_class, Items.Weapon):
                            item_instance = item_class()  # Other items do not need a player reference
                            loot_box.items.append(item_instance)

    def get_starting_point(self):
        room = self.rooms[0]
        x = (room[0])
        y = (room[1])
        print(x, y)
        return [x, y]

    def add_random_items(self):
        items = ["d", "g"]  # "d" for dust, "g" for garbage
        for room in self.rooms:
            x, y, width, height, layout, loot_value, danger, tile = room
            num_items = random.randint(5, 15)  # Adjust the range as needed
            for _ in range(num_items):
                item = random.choice(items)
                attempts = 0
                while attempts < 10:  # Limit attempts to avoid infinite loop
                    item_x = random.randint(x + 1, x + width - 2)  # Avoid placing on walls
                    item_y = random.randint(y + 1, y + height - 2)  # Avoid placing on walls
                    if self.cell_contains(item_x, item_y, tile) and not self.cell_contains(item_x, item_y, item):
                        self.set_cell(item_x, item_y, item)
                        print(f"Item {item} added at ({item_x}, {item_y})")
                        break
                    attempts += 1

    def find_closest_room(self, room):
        x1, y1, _, _ = room
        center1 = (x1 + (room[2] // 2), y1 + (room[3] // 2))

        closest_room = None
        closest_distance = float('inf')

        for existing_room in self.rooms:
            if existing_room == room:
                continue

            x2, y2, _, _ = existing_room
            center2 = (x2 + (existing_room[2] // 2), y2 + (existing_room[3] // 2))  # Center of the existing room

            distance = ((center1[0] - center2[0]) ** 2 + (center1[1] - center2[1]) ** 2) ** 0.5

            if distance < closest_distance:
                closest_distance = distance
                closest_room = existing_room

        return closest_room

    def overlap(self, new_room, existing_room):
        x1, y1, w1, h1 = new_room[:4]
        x2, y2, w2, h2 = existing_room[:4]
        return not (x1 + w1 <= x2 or x2 + w2 <= x1 or y1 + h1 <= y2 or y2 + h2 <= y1)

    def add_room(self, room):
        x, y, width, height, layout, loot_value, danger, tile = room
        for i in range(y, y + height):
            for j in range(x, x + width):
                self.set_cell(j, i, tile)  # Set floor tile

    def enrich_room(self, room, room_content):
        x, y, width, height, layout, loot_value, danger, tile = room
        items = ["d", "g", "s", "r"]  # "d" for dust, "g" for garbage
        for i in range(danger):
            xr = x + random.randint(1, width - 2)
            yr = y + random.randint(1, height - 2)
            enemy_to_add = Entities.Hostile(self.game, [xr, yr], "Assets/Sprites/Entities/Creatures/Walker/walker.png")
            self.set_cell(xr, yr, enemy_to_add)
            self.game.enemies.append(enemy_to_add)

        # Add room-specific content
        for content in room_content:
            if content["layout"] == layout:
                for item in content["content"]:
                    pos_x, pos_y = item["position"]
                    texture_path = item["texture"]
                    item_x = x + pos_x
                    item_y = y + pos_y
                    self.set_cell(item_x, item_y, Entities.Actor(pos=[item_x, item_y], icon=texture_path))

        num_items = random.randint(1, 20)  # Adjust the range as needed
        for _ in range(num_items):
            item = random.choice(items)
            item_x = random.randint(x + 1, x + width - 2)  # Avoid placing on walls
            item_y = random.randint(y + 1, y + height - 2)  #^
            self.set_cell(item_x, item_y, item)
             #   break
        # for s in range(loot_value):
        #     xr = x + random.randint(1, width - 2)
        #     yr = y + random.randint(1, height - 2)
        #     self.set_cell(xr,yr,Entities.Loot(self.game,[xr,yr],"Assets\Sprites\Entities\MapAssets\Loot\Bag\Bag_o.png"))

    def encase_rooms(self):
        for y in range(self.height):
            for x in range(self.width):
                if self.cell_contains(x, y, '.'):
                    if x - 1 >= 0 and self.cell_contains(x - 1, y, ".") is None and self.cell_contains(x - 1, y, Entities.Actor) is None:  # Left
                        self.set_cell(x - 1, y, self.get_wall_sprite((x - 1, y)))
                    if x + 1 < self.width and self.cell_contains(x + 1, y, ".") is None and self.cell_contains(x - 1, y, Entities.Actor) is None:  # Right
                        self.set_cell(x + 1, y, self.get_wall_sprite((x + 1, y)))
                    if y - 1 >= 0 and self.cell_contains(x, y - 1, ".") is None and self.cell_contains(x - 1, y, Entities.Actor) is None:  # Top
                        self.set_cell(x, y - 1, self.get_wall_sprite((x, y - 1)))
                    if y + 1 < self.height and self.cell_contains(x, y + 1, ".") is None and self.cell_contains(x - 1, y, Entities.Actor) is None:  # Bottom
                        self.set_cell(x, y + 1, self.get_wall_sprite((x, y + 1)))

    def connect_rooms(self, room1, room2):
        x1, y1, w1, h1 = room1[:4]
        x2, y2, w2, h2 = room2[:4]

        # centers of the rooms
        center1 = (x1 + w1 // 2, y1 + h1 // 2)
        center2 = (x2 + w2 // 2, y2 + h2 // 2)

        # closest points on the edges of the rooms
        if center1[0] < center2[0]:  # room1 is to the left of room2
            edge1_x = x1 + w1
            edge2_x = x2
        else:
            edge1_x = x1
            edge2_x = x2 + w2

        if center1[1] < center2[1]:
            edge1_y = y1 + h1
            edge2_y = y2
        else:
            edge1_y = y1
            edge2_y = y2 + h2

        #  closest points on edges
        if abs(edge1_x - edge2_x) > abs(edge1_y - edge2_y):
            # Horizontal corridor is longer, so connect vertically first
            edge1 = (edge1_x, random.randint(y1, y1 + h1 - 1))
            edge2 = (edge2_x, random.randint(y2, y2 + h2 - 1))
            self.draw_horizontal_corridor(edge1[0], edge2[0], edge1[1])
            self.draw_vertical_corridor(edge1[1], edge2[1], edge2[0])
        else:
            # Vertical corridor
            edge1 = (random.randint(x1, x1 + w1 - 1), edge1_y)
            edge2 = (random.randint(x2, x2 + w2 - 1), edge2_y)
            self.draw_vertical_corridor(edge1[1], edge2[1], edge1[0])
            self.draw_horizontal_corridor(edge1[0], edge2[0], edge2[1])

        # Place a door
        door = Entities.Door((edge1[0], edge1[1]), "Assets/Sprites/Entities/MapAssets/Door/Door_closed.png")
        door2 = Entities.Door((edge2[0], edge2[1]), "Assets/Sprites/Entities/MapAssets/Door/Door_closed.png")
        self.set_cell(edge1[0], edge1[1], door)
        self.set_cell(edge2[0], edge2[1], door2)

    def draw_horizontal_corridor(self, x1, x2, y):
        for x in range(min(x1, x2), max(x1, x2) + 1):
            self.set_cell(x, y, "bw")
            cell = self.grid[y][x]
            if "r" and "." in cell:
                self.remove_from_cell(x, y, "bw")

    def draw_vertical_corridor(self, y1, y2, x):
        for y in range(min(y1, y2), max(y1, y2) + 1):
            self.set_cell(x, y, "bn")
            cell = self.grid[y][x]
            if "bn" and "." in cell:
                self.remove_from_cell(x, y, "bn")
        min_y, max_y = min(y1, y2), max(y1, y2)
        for y in [min_y, max_y]:
            cell_v = self.get_cell(x, y)
            if "bn" in cell_v:
                if (y == min_y and "." in self.get_cell(x, y - 1)) or \
                        (y == max_y and "." in self.get_cell(x, y + 1)):
                    self.remove_from_cell(x, y, "bn")

    def set_cell(self, x, y, value):
        if 0 <= x < self.width and 0 <= y < self.height:
            self.grid[y][x].append(value)
            self.sort_cell(x, y)

    def remove_from_cell(self, x, y, actor):
        if 0 <= x < self.width and 0 <= y < self.height:
            if actor in self.grid[y][x]:  # Ensure the actor exists in the cell before removing it
                self.grid[y][x].remove(actor)

    def sort_cell(self, x, y):
        if 0 <= x < self.width and 0 <= y < self.height:
            self.grid[y][x].sort(key=sorting_key)

    def get_cell(self, x, y):
        if 0 <= x < self.width and 0 <= y < self.height:
            return self.grid[y][x]
        return []

    def cell_contains(self, x, y, value):
        cell = self.get_cell(x, y)
        for item in cell:
            if isinstance(item, type(value)) or item == value:
                return item
        return None

    def draw(self, surface, camera, visibility_grid):
        floor_sprites = []
        decor_sprites = []
        actor_sprites = []

        for y in range(self.height):
            for x in range(self.width):
                if visibility_grid[y][x]:
                    rect = pygame.Rect(x * self.cell_size - camera[0], y * self.cell_size - camera[1], self.cell_size,
                                       self.cell_size)
                    cell_values = self.grid[y][x]
                    for value in cell_values:
                        if value in self.images:
                            if value == '.' or value == 'sci' or value == 'str':
                                floor_sprites.append((self.images[value], rect))
                            else:
                                decor_sprites.append((self.images[value], rect))
                        if isinstance(value, Entities.Actor):
                            actor_sprites.append((value.icon, rect))

        # Render floor sprites
        for image, rect in floor_sprites:
            surface.blit(image, rect)

        # Render decor sprites
        for image, rect in decor_sprites:
            surface.blit(image, rect)

        # Render actor sprites
        for image, rect in actor_sprites:
            surface.blit(image, rect)

    def get_actors(self):
        actors = []
        for y in range(self.height):
            for x in range(self.width):
                cell_values = self.grid[y][x]
                for value in cell_values:
                    if isinstance(value, Entities.Actor):
                        actors.append(value)
        return actors

    def get_wall_sprite(self, pos):
        x, y = pos
        neighbors = [
            self.get_cell(x - 1, y),  # Left
            self.get_cell(x + 1, y),  # Right
            self.get_cell(x, y - 1),  # Top
            self.get_cell(x, y + 1)  # Bottom
        ]

        # Check if neighbors are walls
        left_wall = any(isinstance(item, Entities.Wall) for item in neighbors[0])
        right_wall = any(isinstance(item, Entities.Wall) for item in neighbors[1])
        top_wall = any(isinstance(item, Entities.Wall) for item in neighbors[2])
        bottom_wall = any(isinstance(item, Entities.Wall) for item in neighbors[3])

        return Entities.Wall(pos, "Assets/Sprites/Entities/MapAssets/Wall/Wall_cnc.png")  # Default wall

    def generate_minimap(self):
        minimap_surface = pygame.Surface((self.width, self.height))
        minimap_surface.fill((0, 0, 0))  # Fill with black background

        for y in range(self.height):
            for x in range(self.width):
                cell = self.get_cell(x, y)
                color = (0, 0, 0)  # Default color (black for unexplored)

                if any(isinstance(item, Entities.Wall) for item in cell):
                    color = (100, 100, 100)
                elif 'elv' in cell:
                    color = (200, 200, 200)
                elif any(isinstance(item, Entities.Actor) for item in cell):
                    color = (0, 255, 0)

                minimap_surface.set_at((x, y), color)

        return minimap_surface


==== Mission_Manager.py ====

import os
import json

class Mission:
    def __init__(self, game, mapgen, mission):
        self.mission = mission
        self.game = game
        self.mapgen = mapgen

    def generate_mission(self):
        missions_list = self.read_mission()
        mission_data = next((m for m in missions_list if m["mission"] == self.mission), None)
        if mission_data:
            name = mission_data["mission"]
            basic = mission_data["basic"]
            danger = mission_data["danger"]
            loot = mission_data["loot"]
            final = mission_data["final"]
            return name,basic,danger,loot,final

    def read_mission(self):
        missions_dir = os.path.dirname(os.path.abspath(__file__))
        asset_path_file = os.path.join(missions_dir, 'Assets', 'dicts', 'mission_types.js')
        with open(asset_path_file, 'r') as f:
            return json.load(f)
    def deploy_mission(self):
        pass


    def complete_mission(self):
        pass


    def end(self, result):
        pass

==== Overworld_game.py ====

import sqlite3
import pygame
import Entities
from Entities import Player, Hostile, Actor, Loot
from UIElements import Rectangle, TextRenderer, Button
import Items
import MapGen
import math
import json

class Game:
    def __init__(self, surface, screen):
        self.font = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 32)
        self.font_small = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 16)
        self.font_ann = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 12)
        self.gameIcon = pygame.image.load("Assets/Sprites/icons/Icon33.png")
        pygame.display.set_icon(self.gameIcon)
        self.highlight = None  # (x, y, (color), end_time)
        self.screen = screen
        self.bgc = pygame.image.load("Assets/Sprites/Backdrops/NormalBackground.png")
        self.bgcd = (15, 20, 18)
        self.camera = [0, 0]
        self.surface = surface
        self.enemies = []
        self.clock = pygame.time.Clock()
        self.grid = MapGen.Grid(80, 80, 40, self)
        self.grid.generate_dungeon()
        self.player_pos = self.grid.get_starting_point()
        self.player = Player(self, self.player_pos, "Assets/Sprites/Entities/Creatures/Player/fig1.png")
        self.grid.generate_loot()
        self.grid.set_cell(self.player_pos[0], self.player_pos[1], self.player)
        for y in range(self.grid.height):
            for x in range(self.grid.width):
                cell = self.grid.get_cell(x, y)
                if isinstance(cell, Hostile):
                    cell.game = self  # Set the game reference for the enemy
                    self.enemies.append(cell)
        self.enemy = Hostile(self, (5 * self.grid.cell_size, 5 * self.grid.cell_size),
                             "Assets/Sprites/Entities/Creatures/Walker/walker.png")
        self.turn_count = 0
        self.is_player_turn = True
        self.visibility_grid = [[False for _ in range(self.grid.width)] for _ in range(self.grid.height)]
        self.vision_radius = 10  # Adjust this value to change the player's vision range
        self.popup = None  # Initialize popup as None
        self.hit_highlight = None  # Initialize hit highlight as None
        self.load_gear()


    def get_player_charater(self):
        return self.player

    def highlight_tile(self, x, y, color, duration):
        self.highlight = (x, y, color, pygame.time.get_ticks() + duration)

    def map_loop(self):
        backdrop = Rectangle(((self.surface.get_width() - 200), 0), (200, self.surface.get_height()), (70, 70, 70))
        turn_text = TextRenderer(self.font_small, (255, 255, 255))
        ammo_icon = pygame.image.load("Assets/Sprites/icons/ammo.png")
        ammo_icon = pygame.transform.scale(ammo_icon, (32, 32))
        ammo_text = TextRenderer(self.font_small, (255, 255, 255))
        weapon_name = TextRenderer(self.font_small, (255, 255, 255))
        health_text = TextRenderer(self.font_small, (255,255,255))
        health_icon = pygame.image.load("Assets/Sprites/icons/Health.png")
        health_icon = pygame.transform.scale(health_icon, (32, 32))
        extract_btn = Button("Evacuation", (self.surface.get_width() - 160, 75), (125, 50), self.font_small, (255,255,0),(0,0,0),enabled =False)
        reload_button = Button("Reload", (self.surface.get_width() - 175, 350), (75, 50), self.font_small)
        inventory_btn = Button("Inventory", (self.surface.get_width() - 175, 650), (150, 50), self.font_small)
        minimap = self.grid.generate_minimap()
        minimap_size = 190  # size minimap
        minimap = pygame.transform.scale(minimap, (minimap_size, minimap_size))
        minimap_pos = (self.surface.get_width() - minimap_size - 5, 450)
        running = True
        inventory_open = False
        self.popup = None
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pass
                if self.is_player_turn:
                    move = self.player.handle_input(event)
                    if move != (0, 0):
                        self.move_player(move)
                        self.is_player_turn = False
                        self.turn_count += 1
                        self.handle_enemy_turn()
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        mouse_pos = pygame.mouse.get_pos()
                        if inventory_open:
                            self.player.handle_inventory_click(mouse_pos)
                            if self.popup:
                                action = self.popup.handle_click(mouse_pos)
                                if action == "use":
                                    if isinstance(self.popup.item, Items.Weapon):
                                        self.player.equip_weapon(self.popup.item)
                                    else:
                                        self.player.inventory.use_item(self.popup.item)
                                elif action == "discard":
                                    self.player.inventory.remove_item(self.popup.item)
                                self.popup = None
                        if extract_btn.is_clicked(mouse_pos):
                            self.save_gear()
                            self.screen.search_new_state("shell")
                        tile_x = (mouse_pos[0] + self.camera[0]) // self.grid.cell_size
                        tile_y = (mouse_pos[1] + self.camera[1]) // self.grid.cell_size
                        cell_values = self.grid.get_cell(tile_x, tile_y)
                        for actor in cell_values:
                            if isinstance(actor, Actor):
                                actor_event = actor.is_clicked(mouse_pos)
                                if actor_event == "attack":
                                    hit_pos = self.player.attack(actor)
                                    if hit_pos:
                                        self.highlight_tile(hit_pos[0], hit_pos[1], (255, 0, 0),
                                                            200)
                                elif actor_event == "search":
                                    self.player.search()
                                elif actor_event == "use":
                                    self.player.use(actor)
                        if reload_button.is_clicked(mouse_pos):
                            if isinstance(self.player.weapon, Items.RangedWeapon):
                                self.player.weapon.reload()
                        elif inventory_btn.is_clicked(mouse_pos):
                            inventory_open = not inventory_open
                            if inventory_open:
                                inventory_btn.text = "Close"
                            else:
                                inventory_btn.text = "Inventory"

            self.surface.blit(self.bgc,(0,0))
            self.update_camera()
            self.update_visibility()  # Update visibility
            clock = pygame.time.Clock()
            fps = str(clock.tick(60))
            pygame.display.set_caption("Raiders of Elysium - Map")
            self.grid.draw(self.surface, self.camera, self.visibility_grid)

            backdrop.draw(self.surface)
            mouse_pos = pygame.mouse.get_pos()

            tile_x = (mouse_pos[0] + self.camera[0]) // self.grid.cell_size
            tile_y = (mouse_pos[1] + self.camera[1]) // self.grid.cell_size

            cell_values = self.grid.get_cell(tile_x, tile_y)

            for actor in cell_values:
                        if isinstance(actor, Actor) and self.visibility_grid[tile_y][tile_x]:
                            info_text = actor.getinfo()
                            text_surface = self.font_ann.render(info_text, True, (255, 255, 255))
                            text_rect = text_surface.get_rect(topleft=(mouse_pos[0] + 10, mouse_pos[1] + 10))
                            self.surface.blit(text_surface, text_rect)
                            pygame.draw.line(self.surface, (255, 255, 255),
                                             (self.player_pos[0] * self.grid.cell_size - self.camera[
                                                 0] + self.grid.cell_size // 2,
                                              self.player_pos[1] * self.grid.cell_size - self.camera[
                                                  1] + self.grid.cell_size // 2),
                                             mouse_pos)
                            if isinstance(actor, Hostile) and isinstance(self.player.weapon, Items.Weapon):
                                distance_x = abs(self.player_pos[0] - tile_x)
                                distance_y = abs(self.player_pos[1] - tile_y)
                                c_info = max(distance_x, distance_y)
                                c_text = f"Distance: {c_info} cells"
                                c_data = "weapon range " + str(self.player.weapon.range) if isinstance(
                                    self.player.weapon, Items.RangedWeapon) else ""
                                hit_chance = self.player.calculate_hit_chance(actor)
                                hit_text = f"Hit Chance: {hit_chance}%"
                                c_surface = self.font_small.render(c_data, True, (255, 255, 255))
                                text_surface = self.font_small.render(c_text, True, (
                                100, 100, 100) if c_info > self.player.weapon.range else (255, 0, 0))
                                hit_surface = self.font_small.render(hit_text, True, (255, 255, 255))
                                text_rect = text_surface.get_rect(topleft=(mouse_pos[0] + 10, mouse_pos[1] + 30))
                                range_rect = text_surface.get_rect(topleft=(mouse_pos[0] + 10, mouse_pos[1] + 50))
                                hit_rect = hit_surface.get_rect(topleft=(mouse_pos[0] + 10, mouse_pos[1] + 70))
                                self.surface.blit(text_surface, text_rect)
                                self.surface.blit(c_surface, range_rect)
                                self.surface.blit(hit_surface, hit_rect)
            else:
                pass

            turn_message = "Your Turn" if self.is_player_turn else "Enemy's Turn"
            turn_text.draw_text(self.surface, turn_message, ((self.surface.get_width() - 150), 50), 100)
            if isinstance(self.player.weapon, Items.Weapon):
                weapon_icon = pygame.image.load(self.player.weapon.icon)
                weapon_name.draw_text(self.surface, self.player.weapon.name, (self.surface.get_width() - 150, 250), 50)
                if isinstance(self.player.weapon, Items.RangedWeapon):
                    ammo_text.draw_text(self.surface, str(self.player.weapon.ammo),
                                        (self.surface.get_width() - 100, 320), 50)
                    reload_button.draw(self.surface)
                    self.surface.blit(ammo_icon, (self.surface.get_width() - 120,300))

            else:
                weapon_icon = pygame.image.load("Assets/Sprites/Items/Weapons/Empty.png")
                weapon_name.draw_text(self.surface, "No weapon", (self.surface.get_width() - 190, 225), 200)

            self.surface.blit(weapon_icon, (self.surface.get_width() - 150, 150))
            if self.player_pos == self.grid.extract_point:
                extract_btn.draw(self.surface)
                extract_btn.set_enabled(True)
            else:
                extract_btn.set_enabled(False)
            #health display
            self.surface.blit(health_icon, (self.surface.get_width() - 180,300))
            health_text.draw_text(self.surface,str(self.player.health.health),(self.surface.get_width() - 160,320),200)
            self.surface.blit(minimap, minimap_pos)

            player_minimap_x = int(self.player_pos[0] * minimap_size / self.grid.width)
            player_minimap_y = int(self.player_pos[1] * minimap_size / self.grid.height)
            pygame.draw.circle(self.surface, (0, 0, 255),
                               (minimap_pos[0] + player_minimap_x, minimap_pos[1] + player_minimap_y), 2)

            #inventory
            if inventory_open:
                self.player.render_inventory(self.surface)
            inventory_btn.draw(self.surface)
            if self.popup:
                self.popup.draw()
            if self.hit_highlight:
                hit_x, hit_y = self.hit_highlight
                pygame.draw.rect(self.surface, (255, 0, 0),
                                 (hit_x * self.grid.cell_size - self.camera[0],
                                  hit_y * self.grid.cell_size - self.camera[1],
                                  self.grid.cell_size, self.grid.cell_size), 2)

            if self.highlight:
                x, y, color, end_time = self.highlight
                if pygame.time.get_ticks() < end_time:
                    pygame.draw.rect(self.surface, color,
                                     (x * self.grid.cell_size - self.camera[0],
                                      y * self.grid.cell_size - self.camera[1],
                                      self.grid.cell_size, self.grid.cell_size))
                else:
                    self.highlight = None

            pygame.display.flip()
            self.clock.tick(60)

        return "shell"

    def pass_turn(self):
        print("Turn passed")
        self.is_player_turn = not self.is_player_turn
        self.handle_enemy_turn()

    def handle_enemy_turn(self):
        print("Enemy's turn")
        for enemy in self.enemies:
            if enemy.alive:
                enemy.take_turn(self.player_pos)
        self.is_player_turn = True

    def update_camera(self):
        self.camera[0] = self.player_pos[0] * self.grid.cell_size - self.surface.get_width() // 2 + self.grid.cell_size // 2
        self.camera[1] = self.player_pos[1] * self.grid.cell_size - self.surface.get_height() // 2 + self.grid.cell_size // 2

    def move_player(self, move):
        new_x = self.player_pos[0] + move[0]
        new_y = self.player_pos[1] + move[1]
        cell_values = self.grid.get_cell(new_x, new_y)
        can_move = True
        for item in cell_values:
            if isinstance(item, Entities.Actor) and item.collision:
                can_move = False
                break
        if can_move:
            self.grid.remove_from_cell(self.player_pos[0], self.player_pos[1],self.player)
            self.player_pos = [new_x, new_y]
            self.grid.set_cell(new_x, new_y, self.player)
            self.player.rect.topleft = (new_x * self.grid.cell_size, new_y * self.grid.cell_size)
            self.player.pos = [new_x, new_y]
            print(self.player.pos, self.grid.get_cell(self.player_pos[0], self.player_pos[1]))

    def update_visibility(self):
        self.visibility_grid = [[False for _ in range(self.grid.width)] for _ in range(self.grid.height)]
        self.cast_rays()

    def cast_rays(self):
        player_x, player_y = self.player_pos
        for angle in range(0, 360, 1):  # raycast by 1 degrees \ head direction mb?
            self.cast_ray(player_x, player_y, math.radians(angle))

    def cast_ray(self, start_x, start_y, angle):
        dx = math.cos(angle)
        dy = math.sin(angle)

        for i in range(self.vision_radius):
            x = int(start_x + dx * i)
            y = int(start_y + dy * i)

            if not self.is_valid(x, y):
                break

            self.visibility_grid[y][x] = True

            if self.is_wall(x, y):
                break

    def is_valid(self, x, y):
        return 0 <= x < self.grid.width and 0 <= y < self.grid.height

    def is_wall(self, x, y):
        cell_values = self.grid.get_cell(x, y)
        return any(isinstance(item, Entities.Wall) for item in cell_values) or (any(isinstance(item, Entities.Door)  and  item.collision == True for item in cell_values ))

    def update_hostile_positions(self):
        self.hostile_positions = {tuple(enemy.pos): enemy for enemy in self.enemies if enemy.alive}

    def show_game_over(self):
        self.clear_gear()
        self.advance_day()

        game_over_font = pygame.font.Font('Assets/fonts/Game/HomeVideo-Regular.otf', 64)
        game_over_text = TextRenderer(game_over_font, (255, 0, 0))
        expl_text = TextRenderer(self.font, (255, 255, 255))
        dead_image = pygame.image.load("Assets/Sprites/Entities/Creatures/Player/fig_dead.png")
        dead_image = pygame.transform.scale(dead_image, (80, 80))

        exit_button = Button("Confirm", (self.surface.get_width() // 2 - 50, self.surface.get_height() // 2 + 120),
                             (150, 50), self.font)
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    mouse_pos = pygame.mouse.get_pos()
                    if exit_button.is_clicked(mouse_pos):
                        self.screen.search_new_state("shell")

            self.surface.blit(self.bgc, (0, 0))
            exit_button.draw(self.surface)
            self.surface.blit(dead_image, (512 - 20, 400 - 20))
            game_over_text.draw_text(self.surface, "Mission Failure", (25, self.surface.get_height() // 2 - 150), 1000,
                                     align="center")
            expl_text.draw_text(self.surface, "Your raider has died and all items have been lost",
                                (self.surface.get_width() // 3, self.surface.get_height() // 2 - 75), 400,
                                align="center")
            pygame.display.flip()
            self.clock.tick(60)

        self.map_loop()

    def check_health(self):
        if self.player.health.health <= 0:
            self.show_game_over()
        elif self.player.health.health <= 35:
            self.bgc = pygame.image.load("Assets/Sprites/Backdrops/DeathBackground.png")
        else:
            self.bgc = pygame.image.load("Assets/Sprites/Backdrops/NormalBackground.png")

    def clear_gear(self):
        conn = sqlite3.connect(self.screen.save[1])
        cursor = conn.cursor()
        cursor.execute("UPDATE profile_data SET gear = '' WHERE day = (SELECT MAX(day) FROM profile_data)")
        conn.commit()
        conn.close()

    def save_gear(self):
        saved_inventory = self.player.inventory.serialize()
        conn = sqlite3.connect(self.screen.save[1])
        cursor = conn.cursor()
        cursor.execute("UPDATE profile_data SET gear = ? WHERE day = (SELECT MAX(day) FROM profile_data)", (json.dumps(saved_inventory),))
        conn.commit()
        conn.close()
        self.advance_day()


    def load_gear(self):
        conn = sqlite3.connect(self.screen.save[1])
        cursor = conn.cursor()
        cursor.execute("SELECT gear FROM profile_data WHERE day = (SELECT MAX(day) FROM profile_data)")
        result = cursor.fetchone()
        conn.close()

        if result and result[0]:
            items_dump = result[0].split(',')
            items_dump = [item.strip('"[] ') for item in items_dump]  # Remove any brackets and extra spaces
            self.player.inventory.items = self.player.inventory.deserialize(items_dump)

    def advance_day(self):
        conn = sqlite3.connect(self.screen.save[1])
        cursor = conn.cursor()
        cursor.execute("UPDATE profile_data SET day = day + 1 WHERE day = (SELECT MAX(day) FROM profile_data)")
        conn.commit()
        conn.close()

==== Shaders.py ====

#import math
import numpy

# def draw_radial_gradient(screen, color1, color2):
#     for y in range(screen.get_height()):
#         for x in range(screen.get_width()):
#             dx = x - screen.get_width() // 2
#             dy = y - screen.get_height() // 2
#             distance = math.sqrt(dx*dx + dy*dy)
#             max_distance = math.sqrt((screen.get_width()//2)**2+(screen.get_height()//2)**2)
#             ratio = distance / max_distance
#             ratio = min(ratio, 1)
#             r = int(color1[0] * (1 - ratio) + color2[0] * ratio)
#             g = int(color1[1] * (1 - ratio) + color2[1] * ratio)
#             b = int(color1[2] * (1 - ratio) + color2[2] * ratio)
#             screen.set_at((x, y), (r, g, b))
def generate_gradient(from_color, to_color, height, width):
    channels = []
    for channel in range(3):
        from_value, to_value = from_color[channel], to_color[channel]
        channels.append(
            numpy.tile(
                numpy.linspace(from_value, to_value, width), [height, 1],
            ),
        )
    return numpy.dstack(channels)


def generate_radial_gradient(center, radius, from_color, to_color, height, width):
    # Create an array to hold the gradient
    gradient = numpy.zeros((height, width, 3), dtype=numpy.uint8)

    # Calculate the distance from the center for each pixel
    for y in range(height):
        for x in range(width):
            # Calculate the distance from the center
            distance = numpy.sqrt((x - center[0]) ** 2 + (y - center[1]) ** 2)
            # Normalize the distance to a value between 0 and 1
            normalized_distance = min(distance / radius, 1.0)

            # Interpolate the color based on the normalized distance
            for channel in range(3):
                # Ensure from_color and to_color are tuples or lists
                gradient[y, x, channel] = int(
                    from_color[channel] + (to_color[channel] - from_color[channel]) * normalized_distance)
    return gradient

==== UIElements.py ====

import pygame



class Button:
    def __init__(self, text, position, size, font, color=(100, 100, 100), text_color=(255, 255, 255), enabled=True, disabled_color=None,selected_color=None):
        self.text = text
        self.position = position
        self.size = size
        self.font = font
        self.color = color
        self.text_color = text_color
        self.rect = pygame.Rect(position, size)
        self.enabled = enabled
        self.selected = False
        self.text_renderer = TextRenderer(font, text_color)
        if disabled_color is not None:
            self.disabled_color = disabled_color
        else:
            self.disabled_color = None
        if selected_color is not None:
            self.selected_color = selected_color
        else:
            self.selected_color = None

    def draw(self, surface):
        if self.selected:
            pygame.draw.rect(surface, self.selected_color, self.rect)
        else:
            if not self.enabled:
                if self.disabled_color is None:
                    disabled_color = (150, 150, 150)  # Example disabled color
                else:
                    disabled_color = self.disabled_color
                pygame.draw.rect(surface, disabled_color, self.rect)
            else:
                pygame.draw.rect(surface, self.color, self.rect)


        text_surfaces = self.text_renderer.render_text(self.text, self.rect.width)
        y_offset = (self.rect.height - sum(text_surface.get_height() for text_surface in text_surfaces)) // 2

        for text_surface in text_surfaces:
            text_rect = text_surface.get_rect()
            text_rect.centerx = self.rect.centerx
            text_rect.y = self.rect.y + y_offset
            surface.blit(text_surface, text_rect)
            y_offset += text_surface.get_height()

    def is_clicked(self, mouse_pos):
        if self.enabled:
            return self.rect.collidepoint(mouse_pos)
        return False

    def set_enabled(self, enabled):
        self.enabled = enabled

    def update_text(self, new_text):
        self.text = new_text


class TextRenderer:
    def __init__(self, font, color=(255, 255, 255),text = None):
        if not isinstance(font, pygame.font.Font):
            raise ValueError("font must be a pygame.font.Font object")
        self.font = font
        self.color = color
        if text != None:
            self.presaved = text

    def render_text(self, text = None, max_width = 9999):
        if text == None and self.presaved!= None:
            text = self.presaved
        words = text.split(' ')
        lines = []
        current_line = []

        for word in words:
            current_line.append(word)
            line_surface = self.font.render(' '.join(current_line), True, self.color)
            if line_surface.get_width() > max_width:
                current_line.pop()
                lines.append(' '.join(current_line))
                current_line = [word]

        lines.append(' '.join(current_line))

        text_surfaces = [self.font.render(line, True, self.color) for line in lines]
        return text_surfaces

    def draw_text(self, surface, text, position, max_width, align='left'):
        text_surfaces = self.render_text(text, max_width)
        x, y = position

        for line_surface in text_surfaces:
            text_rect = line_surface.get_rect()
            if align == 'center':
                text_rect.centerx = x + max_width // 2
            elif align == 'right':
                text_rect.right = x + max_width
            else:  # Default to left alignment
                text_rect.left = x
            text_rect.y = y
            surface.blit(line_surface, text_rect)
            y += line_surface.get_height()
class InputBox:
    def __init__(self, position, size, font):
        self.position = position
        self.color = (0,0,0)
        self.size = size
        self.rect = pygame.Rect(self.position, self.size)
        self.text = ''
        self.active = False
        self.font = pygame.font.Font("Assets/fonts/Game/HomeVideo-Regular.otf", 32)
    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                self.active = not self.active
            else:
                self.active = False
            self.color = (0,0,0) if self.active else (125,125,125)
        if event.type == pygame.KEYDOWN and self.active:
            if event.key == pygame.K_RETURN:
                print(self.text)
                self.text = ""
            elif event.key == pygame.K_BACKSPACE:
                self.text = self.text[:-1]
            else:
                self.text += event.unicode
    def draw(self,screen):
        pygame.draw.rect(screen, self.color, self.rect,2)
        text_surface = self.font.render(self.text, False, (0,0,0))
        screen.blit(text_surface,(self.rect.x + 5, self.rect.y + 5))

    def get_name(self):
        return self.text
class ImageButton:
    def __init__(self, image_normal, image_hovered, image_focused, position, size):
        self.image_normal = image_normal
        self.image_hovered = image_hovered
        self.image_focused = image_focused
        self.position = position
        self.size = size
        self.rect = pygame.Rect(self.position, self.size)
        self.is_hovered = False
        self.is_focused = False
        self.mask_normal = pygame.mask.from_surface(self.image_normal)
        self.mask_hovered = pygame.mask.from_surface(self.image_hovered)
        self.mask_focused = pygame.mask.from_surface(self.image_focused)

    def draw(self, surface):
        if self.is_hovered:
            surface.blit(self.image_hovered, self.rect)
        else:
            if self.is_focused:
                surface.blit(self.image_focused, self.rect)
            else:  # Default to normal image
                surface.blit(self.image_normal, self.rect)

    def is_clicked(self, pos):
        if not self.rect.collidepoint(pos):
            return False

        relative_x = pos[0] - self.rect.x
        relative_y = pos[1] - self.rect.y

        if self.is_hovered:
            return self.mask_hovered.get_at((relative_x, relative_y))
        elif self.is_focused:
            return self.mask_focused.get_at((relative_x, relative_y))
        else:
            return self.mask_normal.get_at((relative_x, relative_y))

    def update(self, mouse_pos):
        if not self.rect.collidepoint(mouse_pos):
            self.is_hovered = False
            return

        relative_x = mouse_pos[0] - self.rect.x
        relative_y = mouse_pos[1] - self.rect.y

        # Use the appropriate mask to determine hover state
        if self.mask_normal.get_at((relative_x, relative_y)):
            self.is_hovered = True
        else:
            self.is_hovered = False

    def in_focus(self, state=False):
        self.is_focused = state
class Rectangle:
    def __init__(self, position, size, color):
        self.position = position
        self.size = size
        self.color = color
        self.rect = pygame.Rect(self.position, self.size)

    def draw(self, surface):
        pygame.draw.rect(surface, self.color, self.rect)

    def is_mouse_over(self, mouse_pos):
        return self.rect.collidepoint(mouse_pos)

==== Utils.py ====

import Entities
import heapq
import MapGen

def get_distance_from_actors(actor1, actor2):
    if isinstance(actor1, Entities.Actor) and isinstance(actor2, Entities.Actor):
        distance_x = abs(actor1.pos[0] - actor2.pos[0])
        distance_y = abs(actor1.pos[1] - actor2.pos[1])
        actor_distance = max(distance_x, distance_y)
        return actor_distance


def a_star_search(grid, start, goal, game):
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def get_neighbors(node):
        neighbors = []
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            x, y = node[0] + dx, node[1] + dy
            if 0 <= x < grid.width and 0 <= y < grid.height:
                cell = grid.get_cell(x, y)
                if not grid.cell_contains(x,y,Entities.Actor): #and not grid.cell_contains(x,y,Entities.Wall):
                    neighbors.append((x, y))
        return neighbors

    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}

    while open_set:
        current = heapq.heappop(open_set)[1]

        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.reverse()
            return path

        for neighbor in get_neighbors(current):
            tentative_g_score = g_score[current] + 1
            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return None

